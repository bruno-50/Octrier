//User data class methods.model.User = {};model.User.password = {};model.User.age ={};//*** Methods//Entity methods.model.User.entityMethods = {};model.User.entityMethods.validatePassword = function(password){	var ha1 = directory.computeHA1(this.ID, password);	return (ha1 === this.HA1Key); //true if validated, false otherwise.};//Class methods.model.User.methods = {};model.User.methods.addUser = function(signUpData) {	// Add a new user account.	var passwordRegexStr, isValid,		sessionRef = currentSession(), // Get session.		promoteToken = sessionRef.promoteWith("Admin"), //temporarily make this session Admin level.		newUser, newCP;		debugger;	if (loginByPassword(signUpData.pseudo, signUpData.password)) {		return {error: 8020, errorMessage: "Ce compte existe déjà"};		} else {		//Check if the password is at least 7 characters and one digit.		if (signUpData.password !== null) {			passwordRegexStr = /^(?=.*\d)[a-zA-Z\d]{7,}$/;			isValid = passwordRegexStr.test(signUpData.password);			if (!isValid) {				return {error: 8025, errorMessage: "Votre Mot de Passe doit avoir au minimum 7 charactères et un chiffre"};			}		}				//Check if password is enterd the same both times on the Sign Up form.		if (signUpData.password !== signUpData.verifypassword) {			return {error: 8030, errorMessage: "Erreur vérification du Mot de Passe"};		}		debugger;		newUser =  ds.User.createEntity();       	newUser.nom = signUpData.nom;         	newUser.prenom = signUpData.prenom;/*       	newUser.dnaiss = signUpData.dnaiss;		if(newUser.ville = signUpData.ville){			 newCP = ds.CodePostal( {ville: newUser.ville});			 newUser.codePost = newCP.Code;			 }		newUser.sect_activ = signUpData.prof;		newUser.equipier = signUpData.equipier;		newUser.photo = signUpData.photo;		newUser.descript = signUpData.descript;*/       	newUser.email = signUpData.email;    		newUser.pseudo = signUpData.pseudo;       	newUser.password = signUpData.password;       	       	//*** Best Pratice ***       	//Save the new User in a Try Catch block and put your validation code for the email address in the User        	// onValidate() method (see model.User.events.onValidate below). This is better than doing validation checks in this        	// function because you may create other methods in the future that save a new User.       	/**/       	try {			newUser.save(); //Save the entity.			sessionRef.unPromote(promoteToken); //Put the session back to normal.			//verfier si le pseudo existe déja.       		if (loginByPassword(signUpData.pseudo, signUpData.password)) {       			return {error: 8010, errorMessage: "Bienvenue dans Octrier"};       		} else {       			return {error: 8090, errorMessage: "Désolé, votre compte n'a pu être crée"};			}		}		catch(e) {			return {error: 8099, errorMessage: e.messages[1]};		}		//*** end Best Pratice ***				//*** Anti-pattern ***       	//Don't check the validity of the email address here. Instead put the check in the        	// onValidate() event method for the User dataclass. ( see model.User.events.onValidate below)		/*		var emailRegexStr = /^[a-zA-Z0-9.-_]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/,			isValid = emailRegexStr.test(newUser.email);				if (!isValid) {			return {error: 8080, errorMessage: "xxemail is invalid."};		} else {			newUser.save(); //Save the entity.       		if (loginByPassword(signUpData.email, signUpData.password)) {       			return {error: 8010, errorMessage: "Congratulations on your new account " + signUpData.nom + "!"};       		} else {       			return {error: 8090, errorMessage: "I'm sorry but we could not sign you up."};			}		}		*/		//end *** Anti-pattern ***				sessionRef.unPromote(promoteToken); //Put the session back to normal.	} // end if (loginByPassword(signUpData.login, signUpData.password))};//Class methods scope.model.User.methods.addUser.scope ="public";//Eventsmodel.User.events = {};model.User.events.onValidate = function() {	var err, emailRegexStr, isValid;	//Check the email to see if it's valid.	if (this.email !== null) {		emailRegexStr = /^[a-zA-Z0-9.-_]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;		isValid = emailRegexStr.test(this.email);		if (!isValid) {			err = {error: 8080, errorMessage: "adresse mail invalide"};		}	}		return err;};//Calculated Attributesmodel.User.password.onGet = function() {	return "*****"; //could also return Null.};model.User.password.onSet = function(value) {	this.HA1Key = directory.computeHA1(this.ID, value);};model.User.age.onGet = function()	{                var                    today,                    interval,                    nbYears,                    age;//debugger;                if (this.dnaiss === null || this.dnaiss === undefined) {                    age = 0;                } else {                    today = new Date();                    interval = today.getTime() - this.dnaiss.getTime();                    nbYears = Math.floor(interval / (1000 * 60 * 60 * 24 * 365.25));                    age = nbYears;                }                return age;};